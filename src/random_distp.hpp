// patch for legacy GCC < 4.8.0

#pragma once
#include "random_eng.hpp"

#define MT19937MIN		 0
#define MT19937MAX       4294967295

// Test for GCC < 4.8.0
#if __GNUC__ < 4 || \
	(__GNUC__ == 4 && (__GNUC_MINOR__ < 8 || \
		(__GNUC_MINOR__ == 8 && \
			__GNUC_PATCHLEVEL__ < 0)))
#define NEED_UNIFREALPATCH 
#define FAIL_ADAPT_INPUT	"template argument must be a floating point type"


namespace __detail
{
	// Determine whether number is a power of 2.
    template<typename _Tp>
	inline bool
	_Power_of_2(_Tp __x)
	{
		return ((__x - 1) & __x) == 0;
	}


	template <unsigned long long _Xp, size_t _Rp>
	struct __log2_imp
	{
		static const size_t 
			value=_Xp & ((unsigned long long)(1) << _Rp) ? 
				_Rp : __log2_imp<_Xp, _Rp - 1>::value;
	};

	template <unsigned long long _Xp>
	struct __log2_imp<_Xp, 0>
	{
		static const size_t value = 0;
	};

	template <size_t _Rp>
	struct __log2_imp<0, _Rp>
	{
		static const size_t value = _Rp + 1;
	};

	template <class _UIntType, _UIntType _Xp>
	struct __log2
	{
		static const size_t 
			value = __log2_imp<_Xp,
				sizeof(_UIntType) * __CHAR_BIT__
				- 1>::value;
	};


	template <class _RealType, size_t __bits>
	auto generate_canonical_t(
		confly::mersenne_twister& __g)
		->_RealType
	{
		// see https://github.com/llvm-mirror/libcxx/blob/master/include/random

		const size_t 
			_Dt= std::numeric_limits<_RealType>::digits;

		const size_t 
			__b= _Dt < __bits ? _Dt : __bits;

		const size_t 
			__logR= __log2<uint64_t, 
				MT19937MAX - MT19937MIN 
				+ uint64_t(1)>::value;

		const size_t 
			__k= __b / __logR + (__b % __logR != 0)
				+ (__b == 0);

		const _RealType 
			_Rp= static_cast<_RealType>(
				MT19937MAX - MT19937MIN) 
					+ _RealType(1);

		_RealType
			__base= _Rp;

		_RealType 
			_Sp= __g() - MT19937MIN;

		for (size_t __i=1; __i<__k;
			++__i, __base*=_Rp)
			_Sp += (__g() - MT19937MIN) * __base;

		return _Sp / __base;
	}

	template <class _RealType, 
		size_t __bits, class _URNG>
	inline auto generate_canonical(_URNG& __g)
		->_RealType
	{// force build failure if using 
		// generators different from MT19937
		return generate_canonical_t<
			_RealType, __bits>(__g);
	}

	template<typename _Engine, typename _DInputType>
	struct _Adaptor
	{
		// An adaptor class for converting the output 
		// of any Generator into the input for a 
		// specific Distribution.
		static_assert(std::is_floating_point<
			_DInputType>::value,
				FAIL_ADAPT_INPUT);

	public:

		_Adaptor(_Engine& __g)
			: _M_g(__g) { }

		_DInputType min() const { return _DInputType(0); }

		_DInputType max() const { return _DInputType(1); }

		
		_DInputType operator()()
		{
			// Converts a value generated by the 
			// adapted random number generator
			// into a value in the input domain 
			// for the dependent random number
			// distribution.
			return generate_canonical<_DInputType,
				std::numeric_limits<_DInputType>::digits,
					_Engine>(_M_g);
		}

	private:

		_Engine& _M_g;
	};
}


template<typename _RealType = double>
class uniform_real_dist
{
	// Uniform continuous distribution for 
	// random numbers.
	// A continuous random distribution on 
	// the range [min, max) with equal
	// probability throughout the range.  
	// The URNG should be real-valued and
	// deliver number in the range [0, 1).
	// https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/random.h

public:

	typedef _RealType result_type;

	struct param_type
	{
		typedef uniform_real_dist<_RealType> distribution_type;

		param_type() 
			: param_type(0) { }

		explicit param_type(
			_RealType __a, 
			_RealType __b = _RealType(1))
			: _M_a(__a), _M_b(__b)
		{
			__glibcxx_assert(_M_a <= _M_b);
		}

		result_type a() const { return _M_a; }

		result_type b() const { return _M_b; }

		friend bool operator==(
			const param_type& __p1, 
			const param_type& __p2)
		{ 
			return __p1._M_a == __p2._M_a 
				&& __p1._M_b == __p2._M_b; 
		}

		friend bool operator!=(
			const param_type& __p1, 
			const param_type& __p2)
		{ 
			return !(__p1 == __p2); 
		}

		private:

		_RealType 
			_M_a;
		_RealType 
			_M_b;
	};

	uniform_real_dist() 
		: uniform_real_dist(0.0) 
	{
		// The lower bound is set to 0.0 and 
		// the upper bound to 1.0
	}

	explicit uniform_real_dist(
		_RealType __a, 
		_RealType __b = _RealType(1))
		: _M_param(__a, __b) 
	{
		// __a [IN] lower bound of the distribution
		// __b [IN] upper bound of the distribution
	}

	explicit uniform_real_dist(
		const param_type& __p)
		: _M_param(__p) 
	{		
	}

	void reset() {}

	result_type a() const { return _M_param.a(); }

	result_type b() const { return _M_param.b(); }

	param_type param() const { return _M_param; }

	void param(
		const param_type& __param) 
	{ 
		_M_param = __param; 
	}

	result_type min() const { return this->a(); }

	result_type max() const { return this->b(); }

	template<typename _GenTy>
	result_type operator()(
		_GenTy& __urng)
	{
		return this->operator()(
			__urng, _M_param); 
	}

	template<typename _GenTy>
	result_type operator()(
		_GenTy& __urng,
		const param_type& __p)
	{
		__detail::_Adaptor<_GenTy, result_type>
		__aurng(__urng);
		return (__aurng() * (__p.b() - __p.a())) 
			+ __p.a();
	}

	template<
		typename _ForwardIterator,
		typename _GenTy>
	void __generate(
		_ForwardIterator __f, 
		_ForwardIterator __t,
		_GenTy& __urng)
	{
		this->__generate(__f, __t, __urng, 
			_M_param);
	}

	template<
		typename _ForwardIterator,
		typename _GenTy>
	void __generate(
		_ForwardIterator __f, 
		_ForwardIterator __t,
		_GenTy& __urng,
		const param_type& __p)
	{ 
		this->__generate_impl(__f, __t,
			__urng, __p); 
	}

	template<typename _GenTy>
	void __generate(
		result_type* __f, 
		result_type* __t,
		_GenTy& __urng,
		const param_type& __p)
	{ 
		this->__generate_impl(__f, __t, 
			__urng, __p); 
	}

	friend bool operator==(
		const uniform_real_dist& __d1,
		const uniform_real_dist& __d2)
	{ 
		return __d1._M_param 
			== __d2._M_param;
	}

private:

	template<
		typename _ForwardIterator,
		typename _GenTy>
	void __generate_impl(
		_ForwardIterator __f,
		_ForwardIterator __t,
		_GenTy& __urng,
		const param_type& __p);

	param_type _M_param;
};

template<typename _IntType = int>
class uniform_int_dist
{
	// Uniform discrete distribution 
	// for random numbers.
	// A discrete random distribution 
	// on the range @f$[min, max]@f$ with equal
	// probability throughout the range.
	// https://github.com/gcc-mirror/gcc/blob/41d6b10e96a1de98e90a7c0378437c3255814b16/libstdc%2B%2B-v3/include/bits/uniform_int_dist.h

public:

	typedef _IntType
		result_type;

	struct param_type
	{
		typedef uniform_int_dist<
			_IntType> 
			distribution_type;

		param_type() 
			: param_type(0) 
		{}

		explicit param_type(
			_IntType __a,
			_IntType __b=std::numeric_limits<
				_IntType>::max())
			: _M_a(__a), _M_b(__b)
		{
			__glibcxx_assert(_M_a <= _M_b);
		}

		result_type a() const { return _M_a; }

		result_type b() const { return _M_b; }

		friend bool operator==(
			const param_type& __p1, 
			const param_type& __p2)
		{
			return __p1._M_a == __p2._M_a 
				&& __p1._M_b == __p2._M_b; 
		}

		friend bool operator!=(
			const param_type& __p1, 
			const param_type& __p2)
		{
			return !(__p1 == __p2);
		}

	private:

		_IntType _M_a;
		_IntType _M_b;
	};

	uniform_int_dist() : uniform_int_dist(0) { }

	explicit uniform_int_dist(
		_IntType __a,
		_IntType __b=std::numeric_limits<
			_IntType>::max())
		: _M_param(__a, __b)
	{}

	explicit uniform_int_dist(
		const param_type& __p)
		: _M_param(__p)
	{}

	void reset() { }

	result_type a() const { return _M_param.a(); }

	result_type b() const { return _M_param.b(); }

	param_type param() const { return _M_param; }

	void param(
		const param_type& __param)
	{ 
		_M_param = __param; 
	}

	result_type min() const { return this->a(); }

	result_type max() const { return this->b(); }

	template<typename _GenTy>
	result_type operator()(
		_GenTy& __urng)
	{ 
		return this->operator()(
			__urng, _M_param); 
	}

	template<typename _GenTy>
	result_type operator()(
		_GenTy& __urng,
		const param_type& __p);

	template<
		typename _ForwardIterator,
		typename _GenTy>
	void __generate(
		_ForwardIterator __f, 
		_ForwardIterator __t,
		_GenTy& __urng)
	{ 
		this->__generate(__f, __t, 
			__urng, _M_param); 
	}

	template<
		typename _ForwardIterator,
		typename _GenTy>
	void __generate(
		_ForwardIterator __f, 
		_ForwardIterator __t,
		_GenTy& __urng,
		const param_type& __p)
	{ 
		this->__generate_impl(__f, __t, 
			__urng, __p); 
	}

	template<typename _GenTy>
	void __generate(
		result_type* __f, 
		result_type* __t,
		_GenTy& __urng,
		const param_type& __p)
	{ 
		this->__generate_impl(__f, __t, 
			__urng, __p); 
	}

	friend bool operator==(
		const uniform_int_dist& __d1,
		const uniform_int_dist& __d2)
	{ 
		return __d1._M_param 
			== __d2._M_param; 
	}

private:

	template<
		typename _ForwardIterator,
		typename _GenTy>
	void __generate_impl(
		_ForwardIterator __f, 
		_ForwardIterator __t,
		_GenTy& __urng,
		const param_type& __p);

	param_type _M_param;
};

template<typename _IntType>
template<typename _GenTy>
typename uniform_int_dist<_IntType>::result_type
	uniform_int_dist<_IntType>::
	operator()(_GenTy& __urng,
		const param_type& __param)
{
	typedef typename _GenTy
		::result_type
		_Gresult_type;

	typedef typename 
		std::make_unsigned<result_type>
		::type
		__utype;

	typedef typename std::common_type<
		_Gresult_type, __utype>
		::type
		__uctype;

	const __uctype 
		__urngmin = __urng.min();

	const __uctype 
		__urngmax = __urng.max();

	const __uctype 
		__urngrange = __urngmax 
		- __urngmin;

	const __uctype __urange
		= __uctype(__param.b()) 
		- __uctype(__param.a());

	__uctype __ret;

	if (__urngrange > __urange)
	{
		// downscaling
		const __uctype __uerange 
			= __urange + 1; // __urange can be zero
		const __uctype __scaling 
			= __urngrange / __uerange;
		const __uctype __past 
			= __uerange * __scaling;
		do
			__ret = __uctype(__urng()) - __urngmin;
		while (__ret >= __past);
		__ret /= __scaling;
	}
	
	else if (__urngrange < __urange)
	{
		// upscaling
		/*
			Note that every value in [0, urange]
			can be written uniquely as
			(urngrange + 1) * high + low
			where
			high in [0, urange / (urngrange + 1)]
			and
			low in [0, urngrange].
		*/
		__uctype __tmp; // wraparound control

		do
		{
			const __uctype __uerngrange 
				= __urngrange + 1;

			__tmp = (__uerngrange * operator()
				(__urng, param_type(0, __urange 
					/ __uerngrange)));

			__ret = __tmp + (__uctype(__urng()) 
				- __urngmin);
		}
		while (__ret > __urange || __ret < __tmp);
	}

	else
	__ret = __uctype(__urng()) - __urngmin;

	return __ret + __param.a();
}

template<
	typename _IntType>
template<
	typename _ForwardIterator,
	typename _GenTy>
void uniform_int_dist<_IntType>::
	__generate_impl(
		_ForwardIterator __f, 
		_ForwardIterator __t,
		_GenTy& __urng,
		const param_type& __param)
{
	__glibcxx_function_requires(
		_ForwardIteratorConcept<_ForwardIterator>)

	typedef typename 
		_GenTy::result_type
		_Gresult_type;
	typedef typename 
		std::make_unsigned<result_type>
		::type 
		__utype;
	typedef typename 
		std::common_type<_Gresult_type, 
		__utype>::type
		__uctype;

	const __uctype __urngmin 
		= __urng.min();
	const __uctype __urngmax 
		= __urng.max();
	const __uctype __urngrange 
		= __urngmax - __urngmin;
	const __uctype __urange
		= __uctype(__param.b()) 
		- __uctype(__param.a());

	__uctype __ret;

	if (__urngrange > __urange)
	{
		if (__detail::_Power_of_2(__urngrange + 1)
			&& __detail::_Power_of_2(__urange + 1))
		{
			while (__f != __t)
			{
				__ret = __uctype(__urng()) 
					- __urngmin;
				*__f++ = (__ret & __urange) 
					+ __param.a();
			}
		}
	
		else
		{
			// downscaling
			const __uctype __uerange 
				= __urange + 1; // __urange can be zero
			const __uctype __scaling 
				= __urngrange / __uerange;
			const __uctype __past 
				= __uerange * __scaling;

			while (__f != __t)
			{
				do
					__ret = __uctype(__urng()) 
						- __urngmin;
				while (__ret >= __past);
					*__f++ = __ret / __scaling 
						+ __param.a();
			}
		}
	}

	else if (__urngrange < __urange)
	{
		// upscaling
		
		// Note that every value in [0, urange]
		// can be written uniquely as
		// (urngrange + 1) * high + low
		// where
		// high in [0, urange / (urngrange + 1)]
		// and
		// low in [0, urngrange].
	
		__uctype __tmp; // wraparound control
	
		while (__f != __t)
		{
			do
			{
				const __uctype __uerngrange 
					= __urngrange + 1;
				__tmp = (__uerngrange * operator()
					(__urng, param_type(
						0, __urange / __uerngrange)));
				__ret = __tmp + (__uctype(__urng()) 
						- __urngmin);
			}
			while (__ret > __urange || __ret < __tmp);

			*__f++ = __ret;
		}
	}

	else while (__f != __t)
		*__f++ = __uctype(__urng()) 
			- __urngmin + __param.a();
}

#else // GCC >= 4.8.0
#define uniform_real_dist std::uniform_real_distribution
#define uniform_int_dist std::uniform_int_distribution
#endif
